<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digital Coin 3D Viewer</title>
  <style>
    body { background: #060606; margin: 0; overflow: hidden; }
    #container { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="container"></div>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x060606);

    const camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0.3, 4.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enablePan = false;
    controls.minDistance = 2.2;
    controls.maxDistance = 6;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.6;
    controls.target.set(0, 0, 0);
    controls.update();

    const geometry = new THREE.CylinderGeometry(1, 1, 0.15, 256, 1, false);
    const loader = new THREE.TextureLoader();

    function handleTextureError(url) {
      const msg = document.createElement('div');
      msg.style.position = 'absolute';
      msg.style.top = '20px';
      msg.style.left = '20px';
      msg.style.color = '#f55';
      msg.style.background = '#222';
      msg.style.padding = '10px';
      msg.style.zIndex = 1000;
      msg.style.fontFamily = 'system-ui, sans-serif';
      msg.textContent = `Failed to load image: ${url}`;
      document.body.appendChild(msg);
    }

    const isFileProtocol = window.location.protocol === 'file:';
    const timestamp = isFileProtocol ? '' : `?v=${Date.now()}`;
    const circuitTexture = loader.load(`darkcoin4a.png${timestamp}`, undefined, undefined, () => handleTextureError('darkcoin4a.png'));
    const ohcrTexture = loader.load(`ohcrlogoGREENBACKa.png${timestamp}`, undefined, undefined, () => handleTextureError('ohcrlogoGREENBACKa.png'));

    circuitTexture.encoding = THREE.sRGBEncoding;
    ohcrTexture.encoding = THREE.sRGBEncoding;

    circuitTexture.center.set(0.5, 0.5);
    circuitTexture.rotation = Math.PI / 2;
    ohcrTexture.center.set(0.5, 0.5);
    ohcrTexture.rotation = Math.PI / 2;

    const edgeMaterial = new THREE.MeshStandardMaterial({
      color: 0x181818,
      metalness: 0.95,
      roughness: 0.18
    });
    const ohcrMaterial = new THREE.MeshStandardMaterial({ map: ohcrTexture, metalness: 0.7, roughness: 0.25 });
    const circuitMaterial = new THREE.MeshStandardMaterial({ map: circuitTexture, metalness: 0.7, roughness: 0.25 });

    const coin = new THREE.Mesh(geometry, [edgeMaterial, ohcrMaterial, circuitMaterial]);
    coin.rotation.x = Math.PI / 2.06;
    coin.rotation.z = Math.PI / 2;
    scene.add(coin);

    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.1);
    keyLight.position.set(3.5, 5, 4.5);
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0x52ffb9, 0.45);
    fillLight.position.set(-4, -2, 3);
    scene.add(fillLight);

    const rimLight = new THREE.PointLight(0x1fb4ff, 0.55, 15);
    rimLight.position.set(-2.5, 2.5, -4);
    scene.add(rimLight);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
